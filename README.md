# BaldaSearcher
## Описание
Данный проект представляет из себя алгоритм быстрого поиска слов по правилам игры «Балда». Он содержит инструменты для создания графа из игрового поля и создания словаря в виде префиксного дерева. В итоге проект я
использую в игре BaldaGame.
## Работа алгоритма
### Словарь
Важную роль в алгоритме играет способ хранения словаря в памяти программы. При загрузке каждое слово записывается в структуру в виде дерева. Каждый узел этого дерева означает конкретную букву слова и ссылается на не более чем 32 поддерева (по количеству букв в алфавите). Узел дерева в программе выглядит так: 

<img src="/images/image2.png" >

Свойство isWord показывает наличие слова в данном узле, letter содержит букву узла, а neighbors содержит всех соседей узла.
Назовём это дерево словарным, в нём содержатся все слова из словаря. Помимо словарного дерева необходимо подготовить ещё одно, в котором содержатся все возможные инвертированные префиксы слов для каждого слова (назовём это дерево инвертированным). К примеру, для слова "балда" в инвертированное дерево попадут следующие строки: "адлаб", "длаб", "лаб", "аб", "б". Даже для тестового словаря с пятью словами такое дерево будет громоздким.
Префиксы словарных слов в этом дереве расположены задом-наперед. Узел в красном кружочке соответствует последней букве инвертированного префикса словарного слова, т.е. соответствует первой букве этого слова.

### Алгоритм поиска
По правилам балды для хода нужно выбрать пустую клетку, и поставить туда любую букву.
Затем нужно составить слово, используя поставленную букву. Данная буква может быть как первой буквой в слове, так и не первой буквой (хоть и капитанство, но это важно). Если бы в правилах было сказано, что поставленная буква должна быть точно первой, то просто используем словарное дерево, двигаясь по полю от поставленной буквы одновременно спускаясь вниз по дереву. Но т.к. поставленная буква может и не быть первой, словарное дерево использовать нельзя, потому что не известно с какого именно узла начинать поиск. Но у нас ещё есть инвертированное дерево. 
Идея такая: из клетки с поставленной буквой движемся по полю, спускаясь по инвертированному дереву. Если находим узел, у которого isWord = true (красный узел), значит это валидный инвертированный префикс слова. Имея префикс слова, можно в словарном дереве найти узел, соответствующий поставленной букве, и далее просто «донайти» оставшийся кусок слова уже в словарном дереве, начиная с этого узла. 
Для того чтобы алгоритм не заходил в клетки, которые ранее для данного слова уже прошёл, для каждого валидного префикса передается Set<Vertex> с посещенными вершинами.
### Более подробный алгоритм
Перебираем все пустые смежные клетки
Для каждой клетки перебираем все буквы алфавита (32 буквы)
Заносим в текущую клетку cell текущую букву letter
Начиная с данной ячейки запускаем поиск валидных префиксов в инвертированном дереве 
Для каждого найденного валидного префикса пытаемся донайти остаток слова
Конец цикла по буквам
Конец цикла по смежным клеткам

### Подробнее об функции поиска
Функция поиска представляет из себя усовершенствованный алгоритм DFS. Она принимает игровое поле, наше словарное дерево и инвертированное словарное дерево. Также функция поиска использует альфа-бета-отсечение. Это позволяет не продолжать «углубляться» в игровое поле, если рассматриваемое сочетание букв не имеет продолжения в словаре:

<img src="/images/image.png" >
